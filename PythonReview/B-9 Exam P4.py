# Exam Practice 4
# 一个正整数，加上 100 后是一个完全平方数，再加上 168 后又是一个完全平方数，请问它是多少？
# 【提示】：math.sqrt()

# 1. 假设这个数为 n，根据题意可得：
#       (1) n 为正整数
#       (2) (n + 100) = p * p
#       (3) (n + 100) + 168 = q * q
#       (4) 可以得到两个正整数 p, q 的关系
# 【注意】：题目并没有说 n 是一个完全平方数，而 n 运算后才是
# 2. 由于正面求解 n 比较难，考虑利用计算机的优点，从可能的 (p, q) 反推符合的结果
#       (1) 利用 1-(4) 的关系式 p * p + 168 = q * q 将题目分解为求两个相差 168 的较小的完全平方数
#       (2) 这之前，最好把循环的范围进行估算，测试阶段可以设如 100 的较小值，次数算出的是 10000 以内的符合要求的值
#           ,否则只好从 1 开始到无穷大【 3. 修正】
#       (3) 但这个思路有个缺点，如果 p, q 乘方的结果非常大，会导致内存溢出
# 3. 修正。【等价条件设错了】
#       (1) 应以 n 为等价条件，否则会出现 n 比 p 还小的情况
#       (2) 进一步筛选 n 为负数的情况 —— left 应有 left > 0
#       (3) 还有一层关系，p < q
# 4. 取值范围的估算。
#       (1) 测试 1000 后，观察发现 p, q 取值会更加接近
#       (2) 隐隐感觉造成变化趋势的差值会向 168 “收敛”，即当 p, q 基数变大时，每一份差值的乘积将变大
#       (3) 比如，需要更少份的 p, q 即可达到 168 的差值（实际上，我不是很懂怎么表述这种现象）
# 【或许可以通过求导，偏微分来判断？】

# 单个值设为 100，可算出 10000 以内的符号条件的 n 值
for p in range(100):
    # left = p * p + 168 # 【有误，不能这样设，应该以 n 为等价条件】
    left = p * p - 100 # left > 0
    for q in range(100):
        right = q * q - 100 - 168
        if left > 0 and left == right:
            n = left
            print(n, p, q)
            break
        else:
            continue
